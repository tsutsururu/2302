# 2302

# 198E Unique Color  diff 1161

解答遷移 TLE WA AC

計測していない

備考

➀ 思考

パスなので dfs ? しかし最短パス = 最短経路なので bfs か～ ⇒ これまでの経路で見た色の集合を管理しながら dfs を実装。また、集合に要素を追加する際、全ての探索済集合が操作されてしまわないようにコピーする必要があると気づく ⇒ TLE ⇒ コピーすると計算量が最悪 O(N^2) (1+2+3+...N) となってしまうことに気が付く 

なんとか探索済みの色を工夫して管理できないか考えたが難しい ⇒ 木であることに注目すると、dfs で探索した経路が必ず最短経路になることに気が付く。これならば帰りがけに探索済みの色を操作できるので勝った ⇒ WA ⇒ 帰りがけで必ず探索済みリストからその色を削除してしまうと、それまでの経路でその色が登場している場合に誤りが生じることに気が付く　⇒ 個数を管理して、0 になれば削除する処理に修正して AC

➁ 感想

木の場合 dfs でも最短経路を求められること。dfs はパス問題(経路記憶問題)に強いことを理解する (bfs では同時に複数の経路を処理する関係で経路記憶に強くない)

# ☆ 216E  Amusement Park   diff  1084  別解を思いつきたい

解答遷移 TLE AC

計測なし

備考

➀　思考

素直に優先度付きキューで最大値を管理して、それを-1して入れなおす処理で TLE (Kの制約より) ⇒ 二分探索っぽい雰囲気を感じながらも実装方法がわからない ⇒ 最大値の乗り物には、次に大きな値の乗り物より楽しさが大きい間乗り続ける。そしてこれらが同値となったタイミングでその乗り物と交互に、そのまた次に大きな値の乗り物より楽しさが大きい間乗り続ける。したがって楽しさが大きい乗り物から順に、次の楽しさの位置まで O(1) で楽しさ総和を加算する処理を繰り返せばよいと考えた。これは全体で O(N) なので十分高速と判断。

なお、途中で K　を超える場合には、⌊ 残数/最大値を持つ乗り物の数 ⌋ で最大値を持つ乗り物すべてに乗れる回数を、残数 mod 最大値 を持つ乗り物の数 で最後に乗れる回数を求めることで、計算を行った

➁ 別解

最大値 m 以上の乗り物すべてに K 回で乗れるか 二分探索することで、限界直前の楽しさを求めることができる。あとは、その楽しさ以上の乗り物にこの値になるまで乗り続け、限界値に 残数回乗れば 答えが求められる。計算量は全体で O(N logK) となって十分高速


# 184D increment of coins  diff 1276

解答遷移 AC

計 1時間程度(A～D は解けそう)

備考

➀ 思考






# 183E Queen on Grid  diff 1288

解答遷移　AC

計 56:25

備考

➀ 思考



# 0202

# ☆ 164D Multiple of 2019  diff

降参

備考
　
➀ 思考

連続区間ではあるが、単調性はないので尺取り法的には考えられない。片側固定していろいろ考えたがわからず降参

➁ 解法

20191111 = 20190000 + 1111　⇒ 20191111 = 1111 (mod 2019) が成立することに注目。つまり、区間の左端から末端までで成す整数と、区間の右端+1 の位置から末端までで成す整数 をそれぞれ 2019 で割った余りが等しければ その区間が条件を満たすことになる。したがって、右端側から余りを計算していき、同じ余りが2つ以上存在するものを 2つ選ぶ組み合わせを求めればよい。計算書は O(N) ただし、巨大整数を生成することを考慮して pow を使う必要があることに注意

③ 定石

連続区間へのアプローチの定石として、「 片側固定 」だけでなく 「 累積差分 」を理解する必要がある。

ある区間 [a,b] を、[1,b] と [1,a-1] の差分で解釈するということである。累積和は これの和 をとった ver ということである。



# 186D Sum of difference  diff 436   2回目

解答遷移 AC

計 06:55

備考

➀ 思考

絶対値の差を考えやくするために A を降順にソート。これによって答えは A0-A1 + A0-A1 + ... A0-AN + A1-A2 +... となるので、末尾側からの累積和を取ればよいと判断


# 182D Wandering  diff 701  2回目

解答遷移 AC

計 18:43

備考

➀　思考

次の移動先は累積和で簡単に求めることができるが、途中でそれよりも先に進んでいるケースを考えなければならない。これには次の移動先に至るまでに進める最大の差を持って置けば、現在地 + その値　で移動できる最大値を更新できる。したがって、1, 現在地 2, 現在の移動差分の最大値 を管理する必要があることが分かった。また、現在地の更新のためには 3,現在の移動差分 も管理する必要がある。⇒ 移動差分は A の累積和で求めて、都度最大値を更新することで移動差分の最大値も同時に求められる。移動差分で現在地を更新しながら、移動差分の最大値と現在地の和で 求めるべき最大値を求めればよいと判断

# 163D Sum of Large Numbers	  diff 960  2回目

解答遷移 AC

計 11:29

備考

➀　思考

個数で和が異なこと、K個選んだ和は (+1+2+...K-1)　～ (N-K-1 + ... N-1 + N) までの連続値となることに注目すれば種類が求まると判断















